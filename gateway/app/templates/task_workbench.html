<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Task Workbench - {{ task.task_id }}</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+Myanmar:wght@400;600;700&display=swap" />
  <link rel="stylesheet" href="/static/pipeline_lab.css" />
  <link rel="stylesheet" href="/static/i18n.css" />
  <link rel="stylesheet" href="/static/css/ui_v185.css">
  <style>
    :root { color-scheme: light; }
    .page.workbench {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .header-card {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .back-link {
      color: #1d4ed8;
      text-decoration: none;
      font-weight: 700;
    }

    .btn-primary {
      background: #2563eb;
      color: #ffffff;
      border: 1px solid #2563eb;
    }
    .btn-primary:hover { filter: brightness(.95); }
    .btn-secondary {
      background: #e5e7eb;
      color: #111827;
      border: 1px solid #d1d5db;
    }
    .btn-secondary:hover { filter: brightness(.98); }
    .btn-primary:disabled,
    .btn-secondary:disabled {
      opacity: 0.7;
      color: #111827;
    }
    h1 { margin: 0; font-size: 1.6rem; font-weight: 800; }
    .status-pill {
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 700;
      background: #e5e7eb;
      color: #374151;
    }
    .badge-ready { background: #dcfce7; color: #15803d; }
    .badge-processing { background: #fef3c7; color: #b45309; }
    .badge-error { background: #fee2e2; color: #b91c1c; }
    .meta-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px 16px;
    }
    .meta-item { font-size: 0.95rem; color: #374151; }
    .meta-item strong {
      display: block;
      color: #0f172a;
      font-size: 0.8rem;
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .muted { color: #64748b; font-size: 0.85rem; }
    .deliverables-grid { grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); }
    .deliverable-card {
      border: 1px solid rgba(15, 23, 42, 0.08);
      border-radius: 14px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      background: #f8fafc;
    }
    .deliverable-card.primary { border-color: rgba(37, 99, 235, 0.35); background: #eef2ff; }
    .deliverable-title { font-weight: 700; font-size: 1rem; color: #0f172a; }
    .deliverable-actions { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .download-link {
      color: #1d4ed8;
      text-decoration: none;
      font-weight: 700;
    }
    .download-link.disabled { color: #9ca3af; pointer-events: none; }
    .copy-row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .copy-btn {
      background: #e2e8f0;
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      font-weight: 600;
      cursor: pointer;
    }
    .copy-btn:hover { background: #cbd5f5; }
    .info-row { display: flex; flex-wrap: wrap; gap: 12px; }
    .info-pill {
      background: #f1f5f9;
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 0.85rem;
      font-weight: 600;
      color: #334155;
    }
    .publish-textarea { width: 100%; min-height: 120px; }
    .steps-grid { grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
    .step-card {
      border: 1px solid rgba(15, 23, 42, 0.08);
      border-radius: 14px;
      padding: 12px;
      background: #ffffff;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .step-card h3 { margin: 0; font-size: 1rem; }
    pre.output-log {
      background: #0f172a;
      color: #e2e8f0;
      border-radius: 12px;
      padding: 12px;
      max-height: 240px;
      overflow: auto;
      white-space: pre-wrap;
    }
    details.panel summary { cursor: pointer; font-weight: 700; }
    @media (max-width: 768px) {
      .header-row { flex-direction: column; align-items: flex-start; }
    }
  </style>
</head>
<body>
  <div class="page workbench">
    <div class="card header-card">
{% set title_key = "ui.workbench.title" %}
{% set title_text = t("page.workbench.title") %}
{% set subtitle_text = t("page.workbench.subtitle", task_id=task.task_id) %}
{% set active_nav = "tasks" %}
{% set secondary_label = t("action.back_tasks") %}
{% set secondary_href = "/tasks" %}
{% include "_topbar.html" %}
      <div class="info-row" style="margin-top:8px;">
        <div id="status-badge" class="status-pill">{{ task.status }}</div>
      </div>
      <div class="meta-grid">
        <div class="meta-item"><strong>{{ t("workbench.meta.task_id") }}</strong><span>{{ task.task_id }}</span></div>
        <div class="meta-item"><strong>{{ t("workbench.meta.platform") }}</strong><span>{{ task.platform or '-' }}</span></div>
        <div class="meta-item"><strong>{{ t("workbench.meta.account") }}</strong><span>{{ task.account_id or '-' }}</span></div>
        <div class="meta-item"><strong>{{ t("workbench.meta.category") }}</strong><span>{{ task.category_key or '-' }}</span></div>
        <div class="meta-item"><strong>{{ t("workbench.meta.language") }}</strong><span>{{ task.content_lang or '-' }}</span></div>
        {% set pipeline = task.pipeline_config or {} %}
        {% set subtitles_mode = pipeline.get("subtitles_mode", "whisper+gemini") %}
        {% set dub_mode = pipeline.get("dub_mode", "auto-fallback") %}
        <div class="meta-item"><strong>{{ t("workbench.meta.pipeline") }}</strong><span>Subtitles: {{ subtitles_mode }} · Dub: {{ dub_mode }}</span></div>
        <div class="meta-item"><strong>{{ t("workbench.meta.status") }}</strong><span>{{ task.status }}</span></div>
        <div class="meta-item"><strong>{{ t("workbench.meta.created") }}</strong><span>{{ task.created_at }}</span></div>
        <div class="meta-item">
          <strong>{{ t("workbench.meta.source_url") }}</strong>
          {% if task_view.source_url_open %}
            <div><a href="{{ task_view.source_url_open }}" target="_blank" rel="noopener">Open source link</a></div>
          {% else %}
            <div class="muted t-secondary">No clickable URL detected.</div>
          {% endif %}
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="section-title">
        <h2>{{ t("workbench.deliverables") }}</h2>
        <div class="secondary">{{ t("workbench.deliverables.subtitle") }}</div>
      </div>
      <div class="section-grid deliverables-grid">
        <div class="deliverable-card primary">
          <div class="deliverable-title">{{ t("workbench.pack") }}</div>
          <div class="deliverable-actions">
            <a id="pack-link" class="download-link disabled" href="/v1/tasks/{{ task.task_id }}/pack" target="_blank" rel="noopener">{{ t("action.download") }}</a>
            <span id="pack-status" class="muted">{{ t("workbench.status.not_ready") }}</span>
          </div>
          <div class="muted" style="margin-top:6px;">{{ t("workbench.deliverables.subtitle") }}</div>
        </div>
        <div class="deliverable-card">
          <div class="deliverable-title">{{ t("workbench.scenes") }}</div>
          <div class="deliverable-actions">
            <a id="scenes-link" class="download-link disabled" href="/v1/tasks/{{ task.task_id }}/scenes" target="_blank" rel="noopener">{{ t("workbench.scenes_download") }}</a>
            <span id="scenes-status" class="muted">{{ t("workbench.status.not_ready") }}</span>
          </div>
          <div class="muted" style="margin-top:6px;">{{ t("workbench.scenes_desc") }}</div>
        </div>
        <div class="deliverable-card">
          <div class="deliverable-title">{{ t("workbench.video") }}</div>
          <div class="deliverable-actions">
            <a id="raw-link" class="download-link disabled" href="/v1/tasks/{{ task.task_id }}/raw" target="_blank" rel="noopener">raw.mp4</a>
            <span id="video-status" class="muted">{{ t("workbench.status.not_ready") }}</span>
          </div>
        </div>
        <div class="deliverable-card">
          <div class="deliverable-title">{{ t("workbench.mm_subtitles") }}</div>
          <div class="deliverable-actions">
            <a id="mm-link" class="download-link disabled" href="/v1/tasks/{{ task.task_id }}/subs_mm" target="_blank" rel="noopener">mm.srt</a>
            <a id="mm-txt-link" class="download-link disabled" href="/v1/tasks/{{ task.task_id }}/mm_txt" target="_blank" rel="noopener">mm.txt</a>
            <a id="origin-link" class="download-link disabled" href="/v1/tasks/{{ task.task_id }}/subs_origin" target="_blank" rel="noopener">origin.srt</a>
            <span id="subs-status" class="muted">{{ t("workbench.status.not_ready") }}</span>
          </div>
        </div>
        <div class="deliverable-card">
          <div class="deliverable-title">{{ t("workbench.mm_audio") }}</div>
          <div class="deliverable-actions">
            <a id="audio-link" class="download-link disabled" href="/v1/tasks/{{ task.task_id }}/audio_mm" target="_blank" rel="noopener">mm_audio</a>
            <span id="audio-status" class="muted">{{ t("workbench.status.not_ready") }}</span>
          </div>
          <audio id="audio-preview" controls style="display:none; width: 100%; margin-top:6px;"></audio>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="section-title">
        <h2>{{ t("workbench.scenes_section") }}</h2>
        <div class="secondary">{{ t("workbench.scenes_desc") }}</div>
      </div>
      <div class="section-grid" style="margin-top:12px;">
        <div class="field">
          <label>{{ t("workbench.scenes_action") }}</label>
          <div class="muted" style="white-space:pre-wrap;">
{{ t("workbench.scenes_help") }}
          </div>
        </div>
        <div class="field">
          <label>{{ t("workbench.scenes_action") }}</label>
          <div class="action-row" style="margin-top:8px; flex-wrap:wrap; gap:8px;">
            <button id="btn-scenes" class="btn-primary">{{ t("workbench.scenes_generate") }}</button>
            <a id="btn-scenes-download" class="btn-secondary disabled" href="/v1/tasks/{{ task.task_id }}/scenes" target="_blank" rel="noopener">{{ t("workbench.scenes_download") }}</a>
            <span id="scenes-step-status" class="muted">{{ t("workbench.status.not_ready") }}</span>
          </div>
          <div id="scenes-error" class="muted" style="margin-top:6px;"></div>
        </div>
      </div>
    </div>

    
    <div class="panel">
      <div class="section-title">
        <h2>{{ t("workbench.publish_hub") }}</h2>
        <div class="secondary">{{ t("workbench.publish_hint") }}</div>
      </div>
      <div class="action-row" style="margin-top:12px; flex-wrap:wrap; gap:8px;">
        <a class="btn-primary" href="/tasks/{{ task.task_id }}/publish">{{ t("workbench.publish_open") }}</a>
      </div>
    </div>
<div class="panel">
      <div class="section-title">
        <h2>{{ t("workbench.steps") }}</h2>
        <div class="secondary">{{ t("workbench.steps.subtitle") }}</div>
      </div>
      <div class="section-grid steps-grid">
        <div class="step-card">
          <h3>{{ t("workbench.step.parse.title") }}</h3>
          <p class="muted">{{ t("workbench.step.parse.desc") }}</p>
          <div class="action-row">
            <button id="btn-parse" class="btn-primary">{{ t("workbench.step.parse.run") }}</button>
            <span id="parse-status" class="muted">{{ t("workbench.status.not_parsed") }}</span>
          </div>
        </div>
        <div class="step-card">
          <h3>{{ t("workbench.step.dub.title") }}</h3>
          <div class="form-grid">
            <div class="field">
              <label for="voice-id">{{ t("workbench.step.dub.voice") }}</label>
              <select id="voice-id">
                <option value="mm_female_1">mm_female_1</option>
                <option value="mm_male_1">mm_male_1</option>
                <option value="mm_female_2">mm_female_2</option>
              </select>
            </div>
            <div class="field">
              <label for="dub-provider">{{ t("workbench.step.dub.engine") }}</label>
              <select id="dub-provider">
                <option value="edge-tts">edge-tts</option>
                <option value="lovo">lovo</option>
              </select>
            </div>
          </div>
          <div class="action-row" style="margin-top:8px;">
            <button id="btn-dub" class="btn-primary">{{ t("workbench.step.dub.run") }}</button>
            <span id="dub-status" class="muted">{{ t("workbench.status.not_ready") }}</span>
          </div>
        </div>
        <div class="step-card">
          <h3>{{ t("workbench.step.pack.title") }}</h3>
          <p class="muted">{{ t("workbench.step.pack.desc") }}</p>
          <div class="action-row">
            <button id="btn-pack" class="btn-primary">{{ t("workbench.step.pack.run") }}</button>
            <span id="pack-step-status" class="muted">{{ t("workbench.status.not_ready") }}</span>
          </div>
        </div>
        <div class="step-card step-wide">
          <h3>{{ t("workbench.step.subtitles.title") }}</h3>
          <p class="muted">{{ t("workbench.step.subtitles.desc") }}</p>
          <div class="action-row">
            <button id="btn-subtitles" class="btn-primary">{{ t("workbench.step.subtitles.run") }}</button>
            <span id="subs-step-status" class="muted">{{ t("workbench.status.not_ready") }}</span>
          </div>
          <details id="subs-compare" style="margin-top:10px;">
            <summary>{{ t("workbench.compare") }}</summary>
            <div style="margin-top:12px; display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
              <div>
                <div class="copy-row" style="justify-content:space-between;">
                  <label style="margin:0;">{{ t("workbench.compare.origin") }}</label>
                  <button type="button" id="btn-copy-origin" class="copy-btn">{{ t("action.copy") }}</button>
                </div>
                <pre id="origin-text" class="output"></pre>
              </div>
              <div>
                <div class="copy-row" style="justify-content:space-between;">
                  <label style="margin:0;">{{ t("workbench.compare.mm") }}</label>
                  <button type="button" id="btn-copy-mm" class="copy-btn">{{ t("action.copy") }}</button>
                </div>
                <pre id="mm-text" class="output"></pre>
              </div>
            </div>

            <div style="margin-top:12px;">
              <div class="copy-row" style="justify-content:space-between;">
                <label for="mm-edit" style="margin:0;">{{ t("workbench.edit.mm") }}</label>
                <div class="copy-row">
                  <button type="button" id="btn-load-edited" class="copy-btn">{{ t("action.reset") }}</button>
                  <button type="button" id="btn-save-edited" class="copy-btn">{{ t("action.save") }}</button>
                </div>
              </div>
              <textarea id="mm-edit" rows="6" style="width:100%; margin-top:8px;"></textarea>
              <div class="muted t-secondary" id="mm-edit-status" style="margin-top:6px;">-</div>
            </div>
          </details>
        </div>
      </div>
    </div>

    <details class="panel" id="debug-panel">
      <summary>{{ t("workbench.logs") }}</summary>
      <div style="margin-top:12px;">
        <h3 style="margin:0 0 8px;">{{ t("workbench.logs.title") }}</h3>
        <pre id="log-output" class="output-log">Ready.</pre>
      </div>
      <div style="margin-top:12px;">
        <h3 style="margin:0 0 8px;">{{ t("workbench.logs.engineering") }}</h3>
        <div class="env-grid">
          <div class="env-card"><div class="env-label"><span>Workspace</span></div><div class="env-value">{{ env_summary.workspace_root }}</div></div>
          <div class="env-card"><div class="env-label"><span>Douyin API</span></div><div class="env-value">{{ env_summary.douyin_api_base }}</div></div>
          <div class="env-card"><div class="env-label"><span>ASR</span></div><div class="env-value">{{ env_summary.asr_backend }}</div></div>
          <div class="env-card"><div class="env-label"><span>Subtitles</span></div><div class="env-value">{{ env_summary.subtitles_backend }}</div></div>
          <div class="env-card"><div class="env-label"><span>Whisper</span></div><div class="env-value">{{ env_summary.whisper_model }}</div></div>
          <div class="env-card"><div class="env-label"><span>Gemini</span></div><div class="env-value">{{ env_summary.gemini_model }}</div></div>
          <div class="env-card"><div class="env-label"><span>GPT</span></div><div class="env-value">{{ env_summary.gpt_model }}</div></div>
          {% if env_summary.defaults %}
          <div class="env-card"><div class="env-label"><span>Defaults</span></div><div class="env-value">{{ env_summary.defaults }}</div></div>
          {% endif %}
        </div>
        <div style="margin-top:10px;" class="section-grid">
          <div class="field">
            <label>{{ t("workbench.origin_subtitles") }}</label>
            <div class="muted t-secondary">See deliverables above.</div>
          </div>
          <div class="field">
            <label>{{ t("workbench.source_url_raw") }}</label>
            <div class="muted t-secondary" style="white-space:pre-wrap; word-break:break-word;">{{ task.source_url or '-' }}</div>
          </div>
        </div>
      </div>
    </details>
  </div>

  <script>
    window.__FEATURES__ = {{ features | tojson | safe }};
    window.currentTask = {{ task_json | tojson | safe }};

    function appendLog(line) {
      const logEl = document.getElementById("log-output");
      if (!logEl) return;
      const now = new Date().toISOString();
      logEl.textContent += `\n[${now}] ${line}`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function updateStatusBadge(data) {
      const badge = document.getElementById("status-badge");
      if (!badge) return;
      const status = data.status || "unknown";
      badge.textContent = status;
      badge.className = `status-pill ${status === "ready"
        ? "badge-ready"
        : status === "processing"
        ? "badge-processing"
        : status === "error"
        ? "badge-error"
        : "badge-unknown"}`;
    }

    function setDownloadLink(id, href) {
      const el = document.getElementById(id);
      if (!el) return;
      if (href) {
        el.href = href;
        el.classList.remove("disabled");
        el.removeAttribute("aria-disabled");
      } else {
        el.href = "#";
        el.classList.add("disabled");
        el.setAttribute("aria-disabled", "true");
      }
    }

    function setStatusText(id, isReady, readyText, missingText) {
      const el = document.getElementById(id);
      if (!el) return;
      el.textContent = isReady ? readyText : missingText;
    }

    function taskEndpoint(taskId, kind) {
      const id = encodeURIComponent(taskId);
      const map = {
        raw: `/v1/tasks/${id}/raw`,
        origin_srt: `/v1/tasks/${id}/subs_origin`,
        mm_srt: `/v1/tasks/${id}/subs_mm`,
        mm_txt: `/v1/tasks/${id}/mm_txt`,
        audio_mm: `/v1/tasks/${id}/audio_mm`,
        pack: `/v1/tasks/${id}/pack`,
        scenes: `/v1/tasks/${id}/scenes`,
      };
      return map[kind] || null;
    }

    function isPresignedLike(url) {
      if (!url) return false;
      const u = String(url);
      return /X-Amz-|Signature=|cloudflarestorage|AWS4-HMAC-SHA256/i.test(u);
    }

    function updateDownloadsFromTask(data) {
      const taskId = data.task_id;
      const hasRaw = !!data.raw_path;
      const hasOrigin = !!data.origin_srt_path;
      const hasMmSrt = !!data.mm_srt_path;
      const hasMmTxt = !!(data.mm_txt_path || data.mm_srt_path);
      const hasAudio = !!data.mm_audio_path;
      const hasPack = !!data.pack_path;
      const hasScenes = !!data.scenes_path;

      setDownloadLink("raw-link", hasRaw ? taskEndpoint(taskId, "raw") : null);
      setDownloadLink("origin-link", hasOrigin ? taskEndpoint(taskId, "origin_srt") : null);
      setDownloadLink("mm-link", hasMmSrt ? taskEndpoint(taskId, "mm_srt") : null);
      setDownloadLink("mm-txt-link", hasMmTxt ? taskEndpoint(taskId, "mm_txt") : null);
      setDownloadLink("audio-link", hasAudio ? taskEndpoint(taskId, "audio_mm") : null);
      setDownloadLink("pack-link", hasPack ? taskEndpoint(taskId, "pack") : null);
      setDownloadLink("scenes-link", hasScenes ? taskEndpoint(taskId, "scenes") : null);
      setDownloadLink("btn-scenes-download", hasScenes ? taskEndpoint(taskId, "scenes") : null);

      setStatusText("video-status", hasRaw, window.__V185_I18N__.t("workbench.status.ready"), window.__V185_I18N__.t("workbench.status.not_ready"));
      setStatusText("subs-status", hasMmSrt || hasMmTxt, window.__V185_I18N__.t("workbench.status.ready"), window.__V185_I18N__.t("workbench.status.not_ready"));
      setStatusText("audio-status", hasAudio, window.__V185_I18N__.t("workbench.status.ready"), window.__V185_I18N__.t("workbench.status.not_ready"));
      setStatusText("pack-status", hasPack, window.__V185_I18N__.t("workbench.status.ready"), window.__V185_I18N__.t("workbench.status.not_ready"));
      setStatusText("scenes-status", hasScenes, window.__V185_I18N__.t("workbench.status.ready"), window.__V185_I18N__.t("workbench.status.not_ready"));

      const audioEl = document.getElementById("audio-preview");
      if (audioEl) {
        if (hasAudio) {
          audioEl.src = taskEndpoint(taskId, "audio_mm");
          audioEl.style.display = "block";
        } else {
          audioEl.removeAttribute("src");
          audioEl.style.display = "none";
        }
      }
    }

    function updateStepStatuses(data) {
      const hasRaw = !!data.raw_path;
      const hasSubs = data.subtitles_status === "ready" || !!(data.mm_srt_path || data.origin_srt_path);
      const hasAudio = !!data.mm_audio_path;
      const hasPack = !!data.pack_path;

      setStatusText("parse-status", hasRaw, window.__V185_I18N__.t("workbench.status.parsed"), window.__V185_I18N__.t("workbench.status.not_parsed"));
      setStatusText("subs-step-status", hasSubs, window.__V185_I18N__.t("workbench.status.ready"), window.__V185_I18N__.t("workbench.status.not_ready"));
      setStatusText("dub-status", hasAudio, window.__V185_I18N__.t("workbench.status.ready"), window.__V185_I18N__.t("workbench.status.not_ready"));
      setStatusText("pack-step-status", hasPack, window.__V185_I18N__.t("workbench.status.ready"), window.__V185_I18N__.t("workbench.status.not_ready"));
    }

    function renderScenesStatus(data) {
      const status = data.scenes_status || (data.scenes_path ? "ready" : "unknown");
      const statusEl = document.getElementById("scenes-step-status");
      const errorEl = document.getElementById("scenes-error");
      const map = {
        queued: window.__V185_I18N__.t("workbench.status.processing"),
        running: window.__V185_I18N__.t("workbench.status.processing"),
        ready: window.__V185_I18N__.t("workbench.status.ready"),
        error: window.__V185_I18N__.t("workbench.status.error", { error: data.scenes_error || "unknown" }),
        already_ready: window.__V185_I18N__.t("workbench.status.ready"),
      };
      if (statusEl) {
        statusEl.textContent = map[status] || window.__V185_I18N__.t("workbench.status.not_ready");
      }
      if (errorEl) {
        errorEl.textContent = status === "error" ? (data.scenes_error || "") : "";
      }
      if (status === "queued" || status === "running") {
        startScenesPolling();
      } else {
        stopScenesPolling();
      }
    }

    const SCENES_POLL_INTERVAL_MS = 15000;
    let scenesPoller = null;
    let scenesPollInFlight = false;

    const SUBS_POLL_INTERVAL_MS = 3000;
    const DUB_POLL_INTERVAL_MS = 3000;
    let subsPoller = null;
    let dubPoller = null;
    let subsPollInFlight = false;
    let dubPollInFlight = false;

    function startScenesPolling() {
      if (document.hidden) return;
      if (scenesPoller) {
        stopScenesPolling();
      }
      scenesPoller = setInterval(() => {
        if (scenesPollInFlight || document.hidden) return;
        scenesPollInFlight = true;
        refreshTaskState()
          .catch(() => {})
          .finally(() => {
            scenesPollInFlight = false;
          });
      }, SCENES_POLL_INTERVAL_MS);
    }

    function stopScenesPolling() {
      if (!scenesPoller) return;
      clearInterval(scenesPoller);
      scenesPoller = null;
    }

    function startSubtitlesPolling() {
      if (document.hidden) return;
      if (subsPoller) {
        stopSubtitlesPolling();
      }
      subsPoller = setInterval(() => {
        if (subsPollInFlight || document.hidden) return;
        subsPollInFlight = true;
        refreshTaskState()
          .catch(() => {})
          .finally(() => {
            subsPollInFlight = false;
          });
      }, SUBS_POLL_INTERVAL_MS);
    }

    function stopSubtitlesPolling() {
      if (!subsPoller) return;
      clearInterval(subsPoller);
      subsPoller = null;
    }

    function startDubPolling() {
      if (document.hidden) return;
      if (dubPoller) {
        stopDubPolling();
      }
      dubPoller = setInterval(() => {
        if (dubPollInFlight || document.hidden) return;
        dubPollInFlight = true;
        refreshTaskState()
          .catch(() => {})
          .finally(() => {
            dubPollInFlight = false;
          });
      }, DUB_POLL_INTERVAL_MS);
    }

    function stopDubPolling() {
      if (!dubPoller) return;
      clearInterval(dubPoller);
      dubPoller = null;
    }

    function refreshPublishInfo(data) {
      const provider = data.publish_provider || "-";
      const key = data.publish_key || "-";
      const at = data.published_at || "-";
      const status = data.publish_status || "-";
      const taskId = data.task_id;
      let url = data.publish_url || "-";
      if (url === "-" || isPresignedLike(url)) {
        url = data.pack_path ? taskEndpoint(taskId, "pack") : "-";
      }

      const providerEl = document.getElementById("publish-provider");
      const keyEl = document.getElementById("publish-key");
      const atEl = document.getElementById("published-at");
      const statusEl = document.getElementById("publish-status");
      const urlEl = document.getElementById("publish-url");
      if (providerEl) providerEl.textContent = provider;
      if (keyEl) keyEl.textContent = key;
      if (atEl) atEl.textContent = at;
      if (statusEl) statusEl.textContent = status;
      if (urlEl) {
        urlEl.textContent = url;
        urlEl.href = url === "-" ? "#" : url;
      }
    }

    function copyTextFromElement(el) {
      if (!el) return;
      const text = el.tagName === "A" ? el.getAttribute("href") : el.textContent || "";
      if (!text || text === "#") return;
      navigator.clipboard.writeText(text).catch(() => {});
    }

    document.querySelectorAll("[data-copy-target]").forEach((btn) => {
      btn.addEventListener("click", () => {
        const targetId = btn.getAttribute("data-copy-target");
        const target = document.getElementById(targetId);
        copyTextFromElement(target);
        appendLog(`Copied ${targetId}.`);
      });
    });

    const copyPublishTextBtn = document.getElementById("copy-publish-text");
    if (copyPublishTextBtn) {
      copyPublishTextBtn.addEventListener("click", async () => {
        const text = (document.getElementById("publish-text") || {}).value || "";
        if (text) {
          await navigator.clipboard.writeText(text);
          appendLog("Copied publish text.");
        }
      });
    }

    updateDownloadsFromTask(window.currentTask);
    updateStatusBadge(window.currentTask);
    updateStepStatuses(window.currentTask);
    refreshPublishInfo(window.currentTask);
    renderScenesStatus(window.currentTask);

    let taskRefreshInFlight = false;
    async function refreshTaskState() {
      if (taskRefreshInFlight) return;
      taskRefreshInFlight = true;
      try {
        const taskId = window.currentTask.task_id;
        const resp = await fetch(`/api/tasks/${taskId}`);
        if (!resp.ok) {
          appendLog(`Failed to refresh task: HTTP ${resp.status}`);
          return;
        }
        const data = await resp.json();
        window.currentTask = data;
        updateDownloadsFromTask(data);
        updateStatusBadge(data);
        updateStepStatuses(data);
        refreshPublishInfo(data);
        renderScenesStatus(data);
        const subsStatus = data.subtitles_status;
        if (subsStatus === "queued" || subsStatus === "running") {
          startSubtitlesPolling();
        } else {
          stopSubtitlesPolling();
        }
        const dubStatus = data.dub_status;
        if (dubStatus === "queued" || dubStatus === "running") {
          startDubPolling();
        } else {
          stopDubPolling();
        }
        if (data.error_message) {
          appendLog(`Last error: ${data.error_message}`);
        }
      } finally {
        taskRefreshInFlight = false;
      }
    }

    document.getElementById("btn-parse").addEventListener("click", async () => {
      const taskId = window.currentTask.task_id;
      const linkText = window.currentTask.source_url || "";
      const platform = window.currentTask.platform || null;
      if (!linkText) {
        appendLog("Parse failed: source_url is empty for this task.");
        return;
      }
      appendLog(`Calling /api/tasks/${taskId}/parse...`);
      const payload = { platform };
      const resp = await fetch(`/api/tasks/${taskId}/parse`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      if (!resp.ok) {
        let errorDetail = `HTTP ${resp.status}`;
        try {
          const payload = await resp.json();
          errorDetail = payload?.detail ? `${errorDetail} - ${payload.detail}` : errorDetail;
        } catch (err) {
          appendLog(`Parse failed: ${errorDetail}`);
          return;
        }
        appendLog(`Parse failed: ${errorDetail}`);
        return;
      }
      appendLog("Parse call finished.");
      await refreshTaskState();
    });

    document.getElementById("btn-subtitles").addEventListener("click", async () => {
      const taskId = window.currentTask.task_id;
      appendLog(`Calling /api/tasks/${taskId}/subtitles...`);
      const resp = await fetch(`/api/tasks/${taskId}/subtitles`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({}),
      });
      if (resp.status === 202) {
        appendLog(window.__V185_I18N__.t("workbench.notice.subtitles_queued"));
        startSubtitlesPolling();
        await refreshTaskState();
        return;
      }
      if (!resp.ok) {
        appendLog(`Subtitles failed: HTTP ${resp.status}`);
        return;
      }
      appendLog("Subtitles call finished.");
      await refreshTaskState();
    });

    document.getElementById("btn-dub").addEventListener("click", async () => {
      const taskId = window.currentTask.task_id;
      const subsReady = window.currentTask.subtitles_status === "ready" || !!window.currentTask.mm_srt_path;
      if (!subsReady) {
        appendLog(window.__V185_I18N__.t("workbench.notice.subtitles_first"));
        return;
      }
      const voiceId = document.getElementById("voice-id").value;
      const provider = document.getElementById("dub-provider").value || "edge-tts";
      appendLog(`Calling /api/tasks/${taskId}/dub (provider=${provider}, voice=${voiceId})...`);
      const payload = { provider, voice_id: voiceId };
      const editedEl = document.getElementById("mm-edit");
      const editedText = editedEl ? editedEl.value.trim() : "";
      if (editedText) {
        payload.mm_text = editedText;
      }
      const resp = await fetch(`/api/tasks/${taskId}/dub`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      if (resp.status === 202) {
        appendLog(window.__V185_I18N__.t("workbench.notice.dub_queued"));
        startDubPolling();
        await refreshTaskState();
        return;
      }
      if (!resp.ok) {
        const detail = await resp.text();
        appendLog(`Dub failed: HTTP ${resp.status} ${detail}`);
        return;
      }
      appendLog("Dub audio ready.");
      await refreshTaskState();
    });

    document.getElementById("btn-pack").addEventListener("click", async () => {
      const taskId = window.currentTask.task_id;
      appendLog(`Calling /api/tasks/${taskId}/pack...`);
      const resp = await fetch(`/api/tasks/${taskId}/pack`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({}),
      });
      if (!resp.ok) {
        appendLog(`Pack failed: HTTP ${resp.status}`);
        return;
      }
      appendLog("Pack ready.");
      await refreshTaskState();
    });

    document.getElementById("btn-scenes").addEventListener("click", async () => {
      const taskId = window.currentTask.task_id;
      const subsReady = window.currentTask.subtitles_status === "ready" || !!window.currentTask.mm_srt_path;
      if (!subsReady) {
        appendLog(window.__V185_I18N__.t("workbench.notice.subtitles_first"));
        return;
      }
      appendLog(`Calling /api/tasks/${taskId}/scenes...`);
      const resp = await fetch(`/api/tasks/${taskId}/scenes`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({}),
      });
      if (!resp.ok) {
        appendLog(`Scenes failed: HTTP ${resp.status}`);
        return;
      }
      const payload = await resp.json();
      appendLog(`Scenes status: ${payload.status}`);
      if (payload.status === "queued" || payload.status === "running") {
        startScenesPolling();
      }
      await refreshTaskState();
    });

    const publishBtn = document.getElementById("publish-btn");
    if (publishBtn) {
      publishBtn.addEventListener("click", async () => {
        const taskId = window.currentTask.task_id;
        const statusEl = document.getElementById("publish-status");
        if (statusEl) statusEl.textContent = "Publishing...";
        try {
          const resp = await fetch(`/api/tasks/${taskId}/publish`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ task_id: taskId, force: false }),
          });
          if (!resp.ok) {
            const detail = await resp.text();
            if (statusEl) statusEl.textContent = `Publish failed: ${resp.status} ${detail}`;
            return;
          }
          if (statusEl) statusEl.textContent = "Published.";
          await refreshTaskState();
        } catch (err) {
          if (statusEl) statusEl.textContent = `Publish error: ${err}`;
        }
      });
    }

    document.addEventListener("DOMContentLoaded", () => {
      refreshTaskState().catch((err) => {
        console.error(err);
        appendLog("Initial refresh failed: " + err);
      });
    });

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        stopScenesPolling();
      } else if (window.currentTask && window.currentTask.scenes_status) {
        const status = window.currentTask.scenes_status;
        if (status === "queued" || status === "running") {
          startScenesPolling();
        }
      }
    });

    window.addEventListener("beforeunload", () => {
      stopScenesPolling();
    });

    async function fetchTextOrFallback(url, fallbackMessage) {
      try {
        const resp = await fetch(url, { method: "GET" });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        return await resp.text();
      } catch (err) {
        console.warn("fetchText failed", url, err);
        return fallbackMessage || `Failed to load. You can use download links above. (${url})`;
      }
    }

    let latestMmText = "";

    async function loadCompareBlock(forceReload) {
      const taskId = window.currentTask.task_id;
      const originPre = document.getElementById("origin-text");
      const mmPre = document.getElementById("mm-text");
      const mmEdit = document.getElementById("mm-edit");
      const statusEl = document.getElementById("mm-edit-status");
      const publishText = document.getElementById("publish-text");
      if (!originPre || !mmPre || !mmEdit) return;

      if (!forceReload && originPre.getAttribute("data-loaded") === "1") {
        return;
      }

      originPre.textContent = "Loading...";
      mmPre.textContent = "Loading...";
      if (statusEl) statusEl.textContent = "Loading...";

      const originUrl = `/api/tasks/${encodeURIComponent(taskId)}/text?kind=origin_srt`;
      const mmTxtUrl = `/api/tasks/${encodeURIComponent(taskId)}/text?kind=mm_txt`;

      const originText = await fetchTextOrFallback(
        originUrl,
        "Unable to load origin subtitles in-browser (possible CORS redirect). Use Downloads -> origin.srt."
      );
      const mmText = await fetchTextOrFallback(
        mmTxtUrl,
        "Unable to load mm text in-browser (possible CORS redirect). Use Downloads -> mm.txt."
      );
      originPre.textContent = originText || "";
      mmPre.textContent = mmText || "";
      if (publishText && !publishText.value) publishText.value = mmText || "";
      const mmTextTrimmed = (mmText || "").trim();
      const mmTextAvailable =
        mmTextTrimmed &&
        !mmTextTrimmed.startsWith("Unable to load") &&
        !mmTextTrimmed.startsWith("Failed to load");
      latestMmText = mmTextAvailable ? mmText : "";
      originPre.setAttribute("data-loaded", "1");

      try {
        const editedUrl = `/api/tasks/${encodeURIComponent(taskId)}/text?kind=mm_edited`;
        const r = await fetch(editedUrl);
        if (r.ok) {
          const text = await r.text();
          if (text && text.trim().length > 0) {
            mmEdit.value = text;
            if (statusEl) statusEl.textContent = "Loaded mm_edited.txt";
          } else {
            mmEdit.value = "";
            if (statusEl) statusEl.textContent = "No mm_edited.txt; click Reset to load mm.txt";
          }
        } else {
          mmEdit.value = "";
          if (statusEl) statusEl.textContent = `mm_edited load failed: HTTP ${r.status}; click Reset to load mm.txt`;
        }
      } catch (err) {
        mmEdit.value = "";
        if (statusEl) statusEl.textContent = "mm_edited load error; click Reset to load mm.txt";
      }
    }

    const detailsEl = document.getElementById("subs-compare");
    if (detailsEl) {
      detailsEl.addEventListener("toggle", () => {
        if (detailsEl.open) loadCompareBlock(false);
      });
    }

    const copyBtnOrigin = document.getElementById("btn-copy-origin");
    if (copyBtnOrigin) {
      copyBtnOrigin.addEventListener("click", async () => {
        const t = (document.getElementById("origin-text") || {}).textContent || "";
        await navigator.clipboard.writeText(t);
        appendLog("Copied origin subtitles.");
      });
    }

    const copyBtnMm = document.getElementById("btn-copy-mm");
    if (copyBtnMm) {
      copyBtnMm.addEventListener("click", async () => {
        const t = (document.getElementById("mm-text") || {}).textContent || "";
        await navigator.clipboard.writeText(t);
        appendLog("Copied mm text.");
      });
    }

    const btnReload = document.getElementById("btn-load-edited");
    if (btnReload) {
      btnReload.addEventListener("click", async () => {
        if (!latestMmText) {
          await loadCompareBlock(true);
        }
        const mmEdit = document.getElementById("mm-edit");
        const statusEl = document.getElementById("mm-edit-status");
        if (mmEdit) mmEdit.value = latestMmText || "";
        if (statusEl) {
          statusEl.textContent = latestMmText
            ? "Reset to mm.txt"
            : "mm.txt not available; use Downloads -> mm.txt";
        }
        appendLog("Reset mm edit from mm.txt.");
      });
    }

    const btnSave = document.getElementById("btn-save-edited");
    if (btnSave) {
      btnSave.addEventListener("click", async () => {
        const taskId = window.currentTask.task_id;
        const mmEdit = document.getElementById("mm-edit");
        const statusEl = document.getElementById("mm-edit-status");
        const text = mmEdit ? mmEdit.value : "";
        if (statusEl) statusEl.textContent = "Saving...";
        try {
          const resp = await fetch(`/api/tasks/${encodeURIComponent(taskId)}/mm_edited`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text }),
          });
          if (!resp.ok) {
            const detail = await resp.text();
            if (statusEl) statusEl.textContent = `Save failed: HTTP ${resp.status} ${detail}`;
            appendLog(`Save mm_edited failed: HTTP ${resp.status}`);
            return;
          }
          if (statusEl) statusEl.textContent = "Saved mm_edited.txt";
          appendLog("Saved mm_edited.txt");
        } catch (err) {
          if (statusEl) statusEl.textContent = `Save error: ${err}`;
          appendLog("Save mm_edited error: " + err);
        }
      });
    }
  </script>
  <script src="/static/js/i18n_v185.js"></script>
</body>
</html>


